/******************************************************************************
 *
 * Copyright (c) 2007, 2008, 2009
 * University of Rochester
 * Department of Computer Science
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *    * Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *    * Neither the name of the University of Rochester nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "GameObjectController.hpp"

using namespace std;

#ifndef _MSC_VER
inline float abs(float f)
{
    return (f > 0) ? f : -f;
}
#endif

void GameObjectController::UpdateState(wr_ptr<GameObjectController> wrThis,
                                       wr_ptr<GameObject> wrMyObject,
                                       unsigned long long ullTimeStamp,
                                       int iThreadID)
{
    int myState = wrThis->get_iState(wrThis);
    sh_ptr<Spatial> spkSpatialProperty =
        wrMyObject->get_pkSpatialProperty(wrMyObject);

    sh_ptr<GamePhysicsProperty> spkPhysicsProperty =
        wrMyObject->get_pkPhysicsProperty(wrMyObject);

    sh_ptr<GameObjectBound> spkBoundProperty =
        wrMyObject->get_pkBoundProperty(wrMyObject);

    switch (myState)
    {
      case GOCS_FLOAT_PHYS :
        // Make sure the object stays inside the main box and also
        // add whatever physics forces are generated by the planets.
        if (spkSpatialProperty && spkPhysicsProperty)
        {
            wr_ptr<Spatial> wrSpatialProperty =
                wr_ptr<Spatial>(spkSpatialProperty);

            wr_ptr<GamePhysicsProperty> wrPhysicsProperty =
                wr_ptr<GamePhysicsProperty>(spkPhysicsProperty);

            float myX, myY, myZ, fx, fy, fz, vX, vY, vZ;

            wrSpatialProperty->GetTranslation(wrSpatialProperty,
                                              myX, myY, myZ);
            wrPhysicsProperty->GetVelocity(wrPhysicsProperty, vX, vY, vZ);

            float boundSize = 50.0f;
            if (myX < -boundSize)
            {
                myX = -boundSize;
                vX = abs(vX);
            }
            if (myY < -boundSize)
            {
                myY = -boundSize;
                vY = abs(vY);
            }
            if (myZ < -boundSize)
            {
                myZ = -boundSize;
                vZ = abs(vZ);
            }

            if (myX > boundSize)
            {
                myX = boundSize;
                vX = -abs(vX);
            }
            if (myY > boundSize)
            {
                myY = boundSize;
                vY = -abs(vY);
            }
            if (myZ > boundSize)
            {
                myZ = boundSize;
                vZ = -abs(vZ);
            }

            wrSpatialProperty->SetTranslation(wrSpatialProperty,
                                              myX, myY, myZ);
            wrPhysicsProperty->SetVelocity(wrPhysicsProperty, vX, vY, vZ);
            Vector3 v3LA = {vX, vY, vZ};
            if (Vector3Length(v3LA) > .25f)
            {
                wrMyObject->StartAnimation(wrMyObject, 0, ullTimeStamp);
            }

            wrPhysicsProperty->ClearForces(wrPhysicsProperty);

            CalculateGravitationalForce(wrPhysicsProperty->get_fMass(wrPhysicsProperty),
                                        myX,  myY, myZ,
                                        fx, fy, fz);

            wrPhysicsProperty->AddForce(wrPhysicsProperty, fx,fy,fz);


            Vector3 lookAt, up, right;
            wrPhysicsProperty->GetLookAtVectors(wrPhysicsProperty,
                                                lookAt, up, right);

            if (Vector3Length(lookAt) > .0001f && Vector3Length(up) > .0001f)
            {
                wrSpatialProperty->SetVectors(wrSpatialProperty,
                                              lookAt, up, right);
            }

            tx_release(wrSpatialProperty);
        }

        break;

      case GOCS_FLOAT :
        // Just make sure the object stays inside our bound box.
        if (spkSpatialProperty && spkPhysicsProperty)
        {
            rd_ptr<Spatial> rdSpatialProperty =
                rd_ptr<Spatial>(spkSpatialProperty);
            wr_ptr<GamePhysicsProperty> wrPhysicsProperty =
                wr_ptr<GamePhysicsProperty>(spkPhysicsProperty);
            float myX, myY, myZ;
            rdSpatialProperty->GetTranslation(rdSpatialProperty,
                                              myX, myY, myZ);

            if (myX < -50.0f)
            {
                float vx, vy, vz;
                wrPhysicsProperty->GetVelocity(wrPhysicsProperty,
                                               vx, vy, vz);
                wrPhysicsProperty->SetVelocity(wrPhysicsProperty,
                                               fabs(vx), vy, vz);
            }

            if (myX > 50.0f)
            {
                float vx, vy, vz;
                wrPhysicsProperty->GetVelocity(wrPhysicsProperty,
                                               vx, vy, vz);

                wrPhysicsProperty->SetVelocity(wrPhysicsProperty,
                                               -fabs(vx), vy, vz);
            }

            if (myZ < -50.0f)
            {
                float vx, vy, vz;
                wrPhysicsProperty->GetVelocity(wrPhysicsProperty,
                                               vx, vy, vz);

                wrPhysicsProperty->SetVelocity(wrPhysicsProperty,
                                               vx, vy, fabs(vz));
            }

            if (myZ > 50.0f)
            {
                float vx, vy, vz;
                wrPhysicsProperty->GetVelocity(wrPhysicsProperty,
                                               vx, vy, vz);

                wrPhysicsProperty->SetVelocity(wrPhysicsProperty,
                                               vx, vy, -fabs(vz));
            }

            tx_release(rdSpatialProperty);
        }

        break;

      case GOCS_HELD :
        // Don't do anything, zero the velocities and play animation 1.
        if (spkPhysicsProperty)
        {
            wr_ptr<GamePhysicsProperty> wrPhysicsProperty =
                wr_ptr<GamePhysicsProperty>(spkPhysicsProperty);
            wrPhysicsProperty->SetVelocity(wrPhysicsProperty,
                                           0,0,0);


            wrMyObject->StartAnimation(wrMyObject, 1, ullTimeStamp);

        }
        break;
    }
}

void GameObjectController::CalculateGravitationalForce(float mass,
                                                       float x,
                                                       float y,
                                                       float z,
                                                       float& fx,
                                                       float& fy,
                                                       float& fz)
{
    fx = fy = fz = 0;

    float gx, gy, gz; // position of gravity

    std::vector< sh_ptr<GameObject> > aObjects =
        WORLD.GetGravitationalObjects();

    for (unsigned int i = 0; i < aObjects.size(); i++)
    {
        if (aObjects[i] != NULL)
        {
            rd_ptr<GameObject> rdObject = rd_ptr<GameObject>(aObjects[i]);

            rd_ptr<GamePhysicsProperty>
                rdPhysics(rdObject->get_pkPhysicsProperty(rdObject));
            float emitMass = rdPhysics->get_fMass(rdPhysics);

            sh_ptr<Spatial> spkSpatialProperty =
                rdObject->get_pkSpatialProperty(rdObject);

            rd_ptr<Spatial> rdSpatial = rd_ptr<Spatial>(spkSpatialProperty);
            rdSpatial->GetTranslation(rdSpatial, gx, gy, gz);
            tx_release(rdSpatial);
            tx_release(rdObject);

            float nx, ny, nz, nLength;
            nx = x - gx;
            ny = y - gy;
            nz = z - gz;

            nLength = sqrt(nx * nx + ny * ny + nz * nz);

            nx /= nLength;
            ny /= nLength;
            nz /= nLength;

            nLength *= nLength;

            float G = 0.01f;//In reality G = 6.67300e-11;

            fx += (-G * mass * emitMass * nx) / (nLength);
            fy += (-G * mass * emitMass * ny) / (nLength);
            fz += (-G * mass * emitMass * nz) / (nLength);
        }
    }
}

void GameObjectController::OnMsg(wr_ptr<GameObjectController> wrThis,
                                 int iMsg, void* msgData,
                                 sh_ptr<GameObject> shMyObject)
{
    if (iMsg == GOCM_SET_TARGET)
    {
        unsigned int uiNewTarget = *(unsigned int*)msgData;
        wrThis->set_pkTarget(GAMESTATE.akGameObjects[uiNewTarget], wrThis);
    }

    // COLLISION DETECT
    if (iMsg == GOCM_COLLIDED)
    {
        // - - - - My Read- - - - - - - - - - - - //
        rd_ptr<GameObject> rdMe(shMyObject);

        sh_ptr<GamePhysicsProperty> spkPhysicsProperty =
            rdMe->get_pkPhysicsProperty(rdMe);

        sh_ptr<GameObjectBound> spkBoundProperty =
            rdMe->get_pkBoundProperty(rdMe);

        sh_ptr<Spatial> spkSpatialProperty =
            rdMe->get_pkSpatialProperty(rdMe);


        wr_ptr<Spatial> wrSpatialProperty(spkSpatialProperty);
        wr_ptr<GamePhysicsProperty> wrPhysicsProperty(spkPhysicsProperty);
        rd_ptr<GameObjectBound> rdBound(spkBoundProperty);


        float myX, myY, myZ;
        float myBoundX, myBoundY, myBoundZ, myRadius;
        wrSpatialProperty->GetTranslation(wrSpatialProperty, myX, myY, myZ);
        rdBound->GetBound(rdBound,myBoundX,myBoundY,myBoundZ, myRadius);

        float vX, vY, vZ;
        wrPhysicsProperty->GetVelocity(wrPhysicsProperty, vX, vY, vZ);

        // - - - - Other Read - - - - - - - - - - //
        sh_ptr<GameObject> collider = *(sh_ptr<GameObject>*)msgData;

        rd_ptr<GameObject> rdOther = rd_ptr<GameObject>(collider);

        sh_ptr<GamePhysicsProperty> shOtherPhysics =
            rdOther->get_pkPhysicsProperty(rdOther);

        sh_ptr<GameObjectBound> shOtherBound =
            rdOther->get_pkBoundProperty(rdOther);

        sh_ptr<GameObjectController> shOtherController =
            rdOther->get_pkControllerProperty(rdOther);

        sh_ptr<Spatial> shOtherSpatial =
            rdOther->get_pkSpatialProperty(rdOther);


        if (shOtherSpatial && shOtherPhysics)
        {
            rd_ptr<GameObjectBound> rdOtherBound(shOtherBound);
            float otherRadius, ox, oy, oz;
            rdOtherBound->GetBound(rdOtherBound,ox,oy,oz,otherRadius);

            Vector3 v3OtherPosition;
            wr_ptr<Spatial> wrOtherSpatial = wr_ptr<Spatial>(shOtherSpatial);
            wrOtherSpatial->GetTranslation(wrOtherSpatial,
                                           v3OtherPosition[0],
                                           v3OtherPosition[1],
                                           v3OtherPosition[2]);

            wr_ptr<GamePhysicsProperty> wrTheirPhysics(shOtherPhysics);

            Vector3 v3TheirVI = {vX,vY,vZ};
            wrTheirPhysics->GetVelocity(wrTheirPhysics,
                                        v3TheirVI[0],
                                        v3TheirVI[1],
                                        v3TheirVI[2]);

            Vector3 v3Delta = {v3OtherPosition[0]-myX,
                               v3OtherPosition[1]-myY,
                               v3OtherPosition[2]-myZ};

            Vector3 v3MyVI = {vX,vY,vZ};



            float myMass, theirMass;
            theirMass = wrTheirPhysics->get_fMass(wrTheirPhysics);
            myMass = wrPhysicsProperty->get_fMass(wrPhysicsProperty);

            float myRadius = rdBound->get_fBoundRadius(rdBound);
            float distance = Vector3Length(v3Delta);
            Vector3Normalize(v3Delta);

            // We have only predictive physics code, so back everything up a'
            // small time amount before physics calculation.
            float time = .01f;
            Vector3 newCenter ={ myX, myY, myZ };
            Vector3 newOtherCenter = { v3OtherPosition[0],
                                       v3OtherPosition[1],
                                       v3OtherPosition[2] };

            // Speed is the rate at which two objects who's bounds overlap
            // move away from each other.
            float speed = myRadius+otherRadius - distance;
            speed += .1f;
            float move = time * speed;


            for (int i = 0; i<3; i++)
            {
                if (myMass < theirMass)
                {
                    newCenter[i] = v3OtherPosition[i] -
                        v3Delta[i] * (myRadius+otherRadius);
                }
                else
                {
                    newCenter[i] -= v3Delta[i] * move;
                    newOtherCenter[i] += v3Delta[i] * move;
                }
            }

            // I am moving towards an object I hit
            if (Vector3Dot(v3Delta,v3MyVI) >= 0.0f)
            {
                float vx1, vy1, vz1, vx2, vy2, vz2;

                vx1 = vX;
                vy1 = vY;
                vz1 = vZ;

                vx2 = v3TheirVI[0];
                vy2 = v3TheirVI[1];
                vz2 = v3TheirVI[2];

                float m1 = myMass;
                float m2 = theirMass;

                if (myMass <= theirMass)
                {
                    myX = newCenter[0];
                    myY = newCenter[1];
                    myZ = newCenter[2];
                }

                if (myMass >= theirMass)
                {
                    v3OtherPosition[0] = newOtherCenter[0];
                    v3OtherPosition[1] = newOtherCenter[1];
                    v3OtherPosition[2] = newOtherCenter[2];
                }

                float x1 = myX - vx1 * time;
                float y1 = myY - vy1 * time;
                float z1 = myZ - vz1 * time;

                float x2 = v3OtherPosition[0] - vx2 * time;
                float y2 = v3OtherPosition[1] - vy2 * time;
                float z2 = v3OtherPosition[2] - vz2 * time;


                int error = 0;

                collision3D(m1, m2, rdBound->get_fBoundRadius(rdBound), otherRadius,
                            x1, y1, z1,
                            x2, y2, z2,
                            vx1, vy1, vz1,
                            vx2, vy2, vz2,
                            error);

                // We damp the collision based on the error status.
                // If the the error is 0 (No error) we drop 85% of 
                // the momentum. 
                //
                // If the error is anything other than 4, we do 
                // nothing and pretend there was no collision.
                //
                // An error of 4 results in stopping everything and
                // occurs when an object has come to rest on another
                // object.
                float damp = 1.0f;
                if (error == 4)
                {
                    damp = 0.0f;
                }
                if (error == 0)
                {
                    damp = .85f;
                }

                float t = time;

                wrPhysicsProperty->SetVelocity(wrPhysicsProperty,damp*vx1,damp*vy1,damp*vz1);
                wrSpatialProperty->SetTranslation(wrSpatialProperty,x1+damp*vx1*t,y1+damp*vy1*t,z1+damp*vz1*t);

                wrOtherSpatial->SetTranslation(wrOtherSpatial,x2+damp*vx2*t,y2+damp*vy2*t,z2+damp*vz2*t);
                wrTheirPhysics->SetVelocity(wrTheirPhysics,damp*vx2,damp*vy2,damp*vz2);
            }
            else
            {
                if (myMass <= theirMass)
                {
                    wrSpatialProperty->SetTranslation(wrSpatialProperty,
                                                      newCenter[0],
                                                      newCenter[1],
                                                      newCenter[2]);
                }

                if (myMass >= theirMass)
                {
                    wrOtherSpatial->SetTranslation(wrOtherSpatial,
                                                   newOtherCenter[0],
                                                   newOtherCenter[1],
                                                   newOtherCenter[2]);
                }
            }
        }
    }
}

void GameObjectController::SetState(wr_ptr<GameObjectController> wrThis,
                                    int iNewState)
{
    if (wrThis->get_iState(wrThis) != GameObjectController::GOCS_FLOAT)
        wrThis->set_iState(iNewState, wrThis);
}

void GameObjectController::SetState(un_ptr<GameObjectController> unThis,
                                    int iNewState)
{
    if (unThis->get_iState(unThis) != GameObjectController::GOCS_FLOAT)
        unThis->set_iState(iNewState, unThis);
}
