#ifndef __ECM_H__
#define __ECM_H__

#ifdef _MSC_VER
#include <time.h>
#include <winsock.h>
#else
//#include <sys/time.h>
#endif

#include "ContentionManager.hpp"
#include <time.h>

/************************** Debug 2 start ****************************************/
#include <iostream>
using namespace std;
/************************** Debug 2 end ****************************************/

namespace stm
{
  /**
   *  Compares the deadline tasks with conflicting transactions
   *  the lower absolute deadline wins
   */
  class ECM: public ContentionManager
  {
    private:
/*
      void onOpen(void)
      {
          defunct = false;
          tries = 0;
          max_tries = MAX_TRIES;
      }
*/
      ConflictResolutions shouldAbort(ContentionManager* enemy);

    public:
	ECM(){}
      
      //The inherited time_param is the input deadline
      timespec* GetDeadline() {return &time_param;}
/*
      time_t GetTimestamp() { return stamp; }
      void SetDefunct() { defunct = true; }
      bool GetDefunct() { return defunct; }

      virtual void onContention()
      {
          defunct = false;
          nano_sleep(INTERVAL);
          tries++;
      }

      virtual void onOpenRead() { onOpen(); }
      virtual void onOpenWrite() { onOpen(); }
      virtual void onTransactionCommitted() { defunct = false; }
      virtual void onTryCommitTransaction() { defunct = false; }
      virtual void onTransactionAborted() { defunct = false; }
*/

      virtual void onBeginTransaction();
      virtual ConflictResolutions onRAW(ContentionManager* e)
      {
          return shouldAbort(e);
      }
      virtual ConflictResolutions onWAR(ContentionManager* e)
      {
          return shouldAbort(e);
      }
      virtual ConflictResolutions onWAW(ContentionManager* e)
      {
          return shouldAbort(e);
      }
  };
}; // namespace stm

inline stm::ConflictResolutions
stm::ECM::shouldAbort(ContentionManager* enemy)
{
    //struct timespec* deadline=this->GetDeadline();
    ECM* t=static_cast<ECM*>(enemy);
    timespec* other_deadline=t->GetDeadline();
    if(time_param.tv_sec < other_deadline->tv_sec){
	return AbortOther;
    }
    else if(time_param.tv_sec == other_deadline->tv_sec && time_param.tv_nsec < other_deadline->tv_nsec){
	return AbortOther;
    }
    //The following case needs to have more restrict criteria
    else if(time_param.tv_sec==other_deadline->tv_sec&&time_param.tv_nsec==other_deadline->tv_nsec){
        return AbortOther;
    }
/*
    Timestamp* t = static_cast<Timestamp*>(enemy);
    defunct = false;

    if (!t)
        return AbortOther;

    // always abort younger transactions
    if (t->GetTimestamp() <= stamp)
        return AbortOther;

    // if it's been a while, mark the enemy defunct
    if (tries == (max_tries/2)) {
        t->SetDefunct();
    }
    // at some point, finally give up and abort the enemy
    else if (tries == max_tries) {
        return AbortOther;
    }
    // if the enemy was marked defunct and isn't anymore, then we reset a bit
    else if ((tries > (max_tries/2)) && (t->GetDefunct() == false)) {
        tries = 2;
        max_tries *= 2;
    }
*/
    return AbortSelf;
}
/*
inline void stm::ECM::onBeginTransaction()
{
  try{
        clock_gettime(CLOCK_REALTIME, &stamp);

        cout<<"stamp:"<<stamp.tv_sec<<" sec, "<<stamp.tv_nsec<<" nsec"<<endl;

    }catch(exception e){
        cout<<"ECM:onBeginTransaction exception: "<<e.what()<<endl;
    }
}
*/
/*
inline void stm::Timestamp::onBeginTransaction()
{
    struct timeval t;

    defunct = false;
    gettimeofday(&t, NULL);
    stamp = t.tv_sec;
}
*/


#endif // __ECM_H__
